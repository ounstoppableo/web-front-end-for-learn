### 导读

在《数据密集型应用系统设计》一书中，有很多专有名词，我们常常有这样一个体验，当我们在阅读某些领域的技术书籍时，一旦遇到一些词语，可能就要花费大量的时间去弄清楚其意思，非常影响我们的阅读体验，并且，这也是进入这个领域的门槛，并不能轻易略过。接下来的内容将给出关于《数据密集型应用系统设计》一书中提到的专有名词的介绍，书内的专有名词不止针对**数据密集型**应用，还囊括许多计算机领域的术语，所以解读该书的专有名词对读者在计算机领域的提升还是很有帮助的。

### 质量属性（非功能需求）

#### 可靠性

可靠性常常会和可用性弄混，可靠性指的是系统在**特定时间内无故障运行**的能力。

#### 可用性

可用性指的是系统**能够为用户正常服务的时间比例**。简单来说，系统故障后恢复时间越短，可用性越强。

### 数据查询语言

#### 命令式查询

命令式语言告诉计算机以特定顺序执行操作，过程可推理。比如从动物列表中获取鲨鱼，命令式查询会这样写：

~~~js
function getSharks(){
    var sharks = [];
    for(var i = 0;i < animals.length; i++){
        if(animals[i].family === 'Sharks'){
            sharks.push(animals[i])
        }
    }
    return sharks
}
~~~

#### 声明式查询

声明式语言则只需**指定结果满足什么条件**，不需要知道结果的具体获取流程，举个例子就是你去点菜，告诉厨师需要什么菜，而不需要去管厨师如何做出来的，而命令式语言则更趋向将做菜的操作原子化，然后通过利用这些原子化命令去自己生成一道菜。常见的声明式语言：sql、html。

#### MapReduce查询

MapReduce是介于命令式查询和声明式查询之间的语言。MapReduce将查询分为三个阶段，第一个阶段是map阶段，用于匹配符合我们给定条件的结果集；第二个阶段是Shuffle阶段（可和第三阶段合并），用于将相同条件的结果分组；第三个阶段是reduce，用于处理结果集成我们希望的模样。简单举例：

~~~sh
输入文件：
hello world
hello mapreduce

Map 阶段输出：
(hello, 1), (world, 1), (hello, 1), (mapreduce, 1)

Reduce 阶段输出：
(hello, 2), (world, 1), (mapreduce, 1)

~~~

**MapReduce vs 传统查询语句**：

| 维度     | MapReduce                                          | sql                                  |
| -------- | -------------------------------------------------- | ------------------------------------ |
| 计算模型 | 分布式计算模型，基于 Map 和 Reduce 阶段            | 关系代数与集合运算，基于关系型数据库 |
| 数据规模 | 处理 PB 级甚至更大规模数据                         | 适合 TB 级及以下数据                 |
| 执行方式 | 批量处理，面向无结构或半结构化数据（如文本、日志） | 即席查询，面向结构化数据             |
| 数据存储 | 支持 HDFS、NoSQL 等分布式文件系统                  | 存储在关系型数据库（如 MySQL）中     |

### 索引结构

#### 哈希索引

哈希索引一般又称为键-值索引，哈希索引可以通过key迅速定位到value，这个过程只需要O(1)的时间复杂度。

#### SSTables和LSM-Tree

SSTables是基于哈希索引做了一些优化，也就是把key进行排序，中文名为排序字符串表。

**SSTables相对普通哈希表**的一个明显**优势**就是：当我们希望从磁盘中读取索引时，不需要完全将其读取至内存，哈希索引因为是乱序的，所以我们必须将其完全读取才能进行索引，而SSTables因为是有序的，所以我们只要知道其附近的key的偏移，就可以以最小的内存成本定位到目标索引。

LSM-Tree是SSTables的读写策略，具体来说：

- 当我们需要写入某个数据时，先写入内存中的平衡树或红黑树数据结构中（这些数据结构能保证顺序存储）或称内存表；

- 当内存表大于某个阈值时，将其作为SSTable文件写入磁盘，由于内存表已经维护了顺序，所以写入SSTable效率高；
- 处理查询请求时，先查内存表，再查磁盘；
- 进程周期性的执行段合并和压缩，减少重复键-值对，提高空间利用率；
- 单独为每次写入构建日志，不需要进行排序，该日志目的只是为了在系统崩溃时恢复内存表，当内存表写入SSTable时即可删除该日志。

#### B-Tree

另一种索引读写策略，相比起LSM-Tree，B-Tree的**读取更快，但是写入更慢（因为需要进行树的拆分和合并）**，但是技术比较成熟，被现有数据库系统广泛使用。

#### 多列索引

前面的索引都是一个key对应一个value，而多列索引则是多个key对应一个value。假设我们有这样一个查询：

~~~sql
SELECT * FROM restaurants WHERE latitude > 51.4946 AND latitude < 51.5079 AND longitude > -0.1162 AND longitude < -0.1004;
~~~

使用一个key对应一个value的LSM-Tree或B-Tree是无法高效定位的，以mysql举例，如果是分别针对latitude和longitude建立索引，那么我们只能分别获取到latitude的范围结果和longitude的范围结果，最后可能又要遍历所有这些结果以找到最终结果；但是如果我们对latitude和longitude建立多列索引，那么我们就可以快速的获取到这个范围，比如下图：

![](.\images\Snipaste_2025-02-01_15-33-54.jpg)

对于多列索引，一般是先将左侧的索引排序好之后再从左往右来排序。比如上述的例子就是先将lantitude先在B-Tree中排列好，之后再排longitude的顺序，所以会出现图中lantitude=51.5050时longitude=-0.1150的情况。

#### 全文搜索

全文搜索（Full-Text Search）是一种用于 **搜索和匹配文本内容** 的技术，能够在大量文档或数据库中快速定位包含特定关键词或短语的记录。

与传统的精确匹配查询不同，全文搜索可以基于 **词语切分、匹配度、语义分析** 等方式返回更相关的结果。

### 数据库数据处理模式

#### 事务处理系统（OLTP）

在线事务处理（online transaction processing，OLTP），这种模式是我们最常接触的数据库数据处理模式，也是默认的数据库处理模式，简单来说就是我们需要的结果集只是**少量的行**。

#### 分析系统（OLAP）

在线分析处理（online analytical processing，OLAP），用于进行数据分析，其需要遍历**大量的数据行**以进行汇总和分析。

### 数据仓库

这是为了应对当我们在同一个数据库系统同时运行OLTP和OLAP时，OLAP导致的OLTP的运行效率低下的问题，数据仓库为这些OLTP系统的副本，OLAP在数据仓库运行时可以完全不干扰OLTP的使用。

#### ETL

ETL是数据仓库的生成方式，数据仓库可以被看成是一个单独的数据库，而ETL则是创建、更新该数据库的方式，ETL分为提取-转换-加载三个阶段，简单来讲：

- 从OLTP系统中提取数据
- 转换为分析友好的模式
- 执行必要的过滤，加载到数据仓库中

### 数据库复制

#### 主从复制

所有客户端写入操作都发送到某一个节点（主节点），由该节点负责将数据更改时间发送到其他副本（从节点）。每个副本都可以接受读请求，但内容可能是过期值。

![](.\images\Snipaste_2025-02-02_20-37-41.jpg)

#### 多主节点复制

系统存在多个主节点，每个都可以接受写请求，客户端将写请求发送到其中的一个主节点上，由该主节点负责将数据更改事件同步到其他主节点和自己的从节点。**用于防止单主节点的主节点崩溃后写入瘫痪问题**。

![](.\images\Snipaste_2025-02-02_20-41-53.jpg)

#### 无主节点复制

客户端写请求发送到多个节点上，读取时从多个节点上并行读取，以此检测和纠正某些过期数据。**主节点模式维护成本高，无主节点可以作为替代方案**。

![](.\images\Snipaste_2025-02-02_20-51-38.jpg)

### 复制滞后

**复制滞后是主节点模式中出现的问题。**

#### 写后读一致性

![](.\images\Snipaste_2025-02-02_20-58-16.jpg)

上图为写后读不一致的情况，写后读一致则是保证用户总能看到自己所提交的最新数据。

#### 单调读

![](.\images\Snipaste_2025-02-02_21-00-36.jpg)

上图为违反单调读的情况，两次读取结果不一致。单调读需要保证用户在某个时间点读到数据之后，保证此后不会出现比该事件点更早的数据。

#### 前缀一致读

![](.\images\Snipaste_2025-02-02_21-08-05.jpg)

上图是违反前缀一致读的情况。前缀一致读需要保证数据之间的因果关系，例如，总是以正确的顺序先读取问题，然后看到回答。

### ACID

#### 原子性

事务是数据库操作的最小单元，要么全部执行成功，要么完全不执行。

#### 一致性

事务执行前后，数据库必须保持一致状态，遵守所有的约束规则（如主键、外键、唯一性约束等）。比如：如果账户转账完成，总余额仍然不变，数据满足业务逻辑。

#### 隔离性

并发事务之间相互隔离，防止并发操作导致数据不一致。

##### 隔离级别

###### 读-提交

保证:

- 读数据库时，只能看到已成功提交的数据（防止“脏读”）
- 写数据库时，只会覆盖已成功提交的数据（防止“脏写”）

###### 快照隔离（可重复读）

保证可重复读，多次读取同一数据结果一致（避免幻读）。常见技术：

- MVCC

###### 可串行化

可串行化即保证并行的事务最终执行结果与每次只执行一个的结果相同。下面是实现可串行化使用的三个技术：

- 严格按照创行顺序执行
- 两阶段锁
- 乐观并发控制技术

##### 隔离问题

**我们需要首先明确，隔离问题发生单元都是事务。**

###### 脏读

客户端读到了其他客户端尚未提交的写入。

![](.\images\Snipaste_2025-02-02_19-45-18.jpg)

###### 脏写

客户端覆盖了另一个客户端尚未提交的写入，意思是在事务1完成写后，尚未提交，此时事务2覆盖了事务1的写入，于是造成事务1提交后的结果不对，但是一般来说写入和提交应该是一个事务的原子操作，所以如果事务1晚提交，那么结果应该为事务1的结果。目前所有数据库系统都能防止脏写。

![](.\images\Snipaste_2025-02-02_19-47-32.jpg)

###### 读倾斜（不可重复读）

客户端在一个事务执行的不同时间点看到了不同的值。

![](.\images\Snipaste_2025-02-02_19-52-15.jpg)

###### 更新丢失

两个客户端同时执行读-修改-写入操作序列，出现了其中一个覆盖了另一个的写入，但又没有包含对方最新值的情况，最终导致了部分修改数据发生了丢失。**更新丢失和脏写的区别**在于，更新丢失的写入到提交之间其他事务是无法参与数据行的修改的，也就是事务在写入时给数据上了锁，而脏写则是在写入和提交之间被别的事务干扰了，简单来讲脏写没满足基本的写入隔离。

![](.\images\Snipaste_2025-02-02_19-56-16.jpg)

###### 写倾斜

事务首先查询数据，根据返回的结果而做出某些决定，然后修改数据库。当事务提交时，支持决定的前提条件已经不再成立。

![](.\images\Snipaste_2025-02-02_20-05-02.jpg)

###### 幻读

事务读取了某些符合查询条件的对象，同时另一个客户端执行写入，改变了先前的查询结果。于是该事务获取了不该获取的查询结果。

![](.\images\Snipaste_2025-02-02_20-06-23.jpg)

##### 串行化隔离解决方案

###### 严格串行执行事务

将并行事务串行执行。

###### 两阶段锁事务

- 如果事务A已经读取了某个对象，此时事务B想要写入该对象，那么B必须等到A提交或中止才能继续。以确保B不会在事务A执行的过程中去修改对象
- 如果事务A已经修改了对象，此时事务B想要读取该对象，则B必须等到A提交或中止之后才能继续

###### 可串行化的快照隔离（SSI）

基于乐观锁的一种并发事务控制方法。

#### 持久性

事务一旦提交，修改结果永久保存，即使系统崩溃也不会丢失数据。

### 分布式

#### 拜占庭故障

在分布式系统中，我们获取结果有一种方法是通过大多数节点的结果而确定最终结果，所谓少数服从多数，但是如果多数的答案是错的，那么我们获取的结果就是错误，这种多数节点撒谎的情况被称为拜占庭故障。

### 一致性与共识

#### 可线性化

在分布式数据库系统中，可能会出现查询两个数据副本会得到两个答案的情况，这通常是因为更新延时造成的，比如其中一个从节点更新了数据，另一个从节点还没更新，第一次用户查的是第一个从节点，获取到了正确的数据，然而第二次查了第二个从节点，这时就发现结果不一致了，如下图所示：

![](.\images\Snipaste_2025-02-02_20-16-29.jpg)

而线性化则是保证让一个系统看起来好像只有一个数据副本。

#### CAP理论

- C：consistency（一致性）

  所有节点访问到的数据必须一致，即 **所有用户无论在哪个节点查询，都会得到相同结果**。

- A：availability（可用性）

  每个请求都能得到 **非错误响应**，即使某些节点失效也不影响服务。

- P：partition tolerance（分区容忍性）

  即使网络通信出现 **节点分区（Partition）故障**，系统仍然能够继续提供部分服务。

这三个属性用于描述分布式系统中的权衡关系，CAP 定理指出：

> **在分布式系统中，不可能同时完全满足一致性、可用性和分区容忍性，只能三者中取其二。**

#### 全序

全序的含义是从某个集合中任意取出两个元素，可以明确的知道这两个元素的排序，这个集合就是全序集合。比如{1,2,3,4,5,6}，拿出2,6我们能清楚知道6在2的后面。

#### 两阶段提交

两阶段提交从应用程序在多个数据库节点上执行数据读/写开始。这些数据库节点被称为参与者，而要实现二阶段提交还有一个第三方中间件事务管理器（协调者），具体流程如下：

- 应用程序准备提交事务，协调者开始**第一阶段**，先发送一个准备请求到所有参与者，询问它们是否可以提交
- 协调者跟踪参与者回应：
  - 所有参与者回答“是”，表示它们已经准备好提交，协调者开始**第二阶段**，发送提交请求，提交开始实际执行。
  - 如果存在参与者回答“否”，协调者开始**第二阶段**，发送放弃请求

两阶段提交主要是为了解决事务在多节点提交时的原子性问题。

### 批处理

批处理是一种**离线**的**定期**执行的针对**大量数据**的一种**长时间**的数据分析操作。

应用场景：

- 数据分析与报表
- 金融清算
- 日志处理
- 数据迁移与备份

### 流处理

**流处理（Stream Processing）** 是一种对 **连续、实时到达的数据流** 进行处理的计算模式，与 **批处理（Batch Processing）** 相对。它能够在数据产生的瞬间进行分析、计算与响应。

应用场景：

- 金融监控
- 物联网
- 日志分析
- 推荐系统
- 自动告警系统

#### 幂等性

多次操作所获得的结果和只操作一次所获得的结果一致。这在网络传输中很有效，比如我们远程操作一个文件添加操作，如果网络卡顿，用户迟迟得不到反馈就多操作了几次，如果是符合幂等性的系统，那么最终只会生成一个文件。

### 参考文献

[数据密集型应用系统设计](https://book.douban.com/subject/30329536/)

