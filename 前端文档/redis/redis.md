## Redis简述

### Redis相对其他数据库的不同

Redis是一个非关系型数据库，其与其他数据库的区别：

![](.\image\QQ截图20240323163703.png)

### Redis的数据结构

Redis是通过散列的方式进行数据存储的，散列有key与value两个部分，而value的存储方式有八种：

- String（字符串）

  内部编码有三种：

  - int：8个字节的长整型
  - embstr：小于等于39个字节的字符串
  - raw：大于39个字节的字符串

- List（列表）

  内部编码有两种:

  - ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries 配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节）时，list使用该方式存储
  - linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。

- Set（集和）

  内部编码有两种：

  - intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，set使用该方式存储。
  - hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis 会使用hashtable作为集合的内部实现。

- Hash（散列）

  内部编码有两种：

  - ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，hash使用该方式存储
  - hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis 会使用hashtable作为哈希的内部实现。

- Zset（有序集和）

  内部编码有两种：

  - ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节），Zset使用该方式存储
  - skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。

- bitmaps（位图）：一个二进制字符串，我们可以将各种数据映射到该字符串上，从而进行位运算，我们知道位运算的计算成本是很低的。比如可以将用户id映射到bitmaps上，0/1来判断每个用户是否做了某事

- HyperLogLogs（超日志）：***本质是字符串***，但是是基于一种基数算法来进行存储，***可以实现集和的效果***，存储同样的东西牺牲的内存相比集和更小

- Streams0（流）：只追加的集合，它由类map提供抽象日志数据类型的元素组成。可以参考 [Introduction to Redis Streams](http://www.redis.com.cn/topics/streams-intro)。

前五种存储方式的具体定义：

![](.\image\QQ截图20240323164347.png)

> 内部编码的含义我们可以简单理解为对于某种存储方式redis会根据具体存储的值的大小而选择开辟的空间的大小，理解内部编码对于内存的合理使用有重要意义，具体可以参考后续***内存不合理分配***章节。

### Redis通信协议

Redis客户端与服务端进行通信使用的是***RESP***(REdis Serialization Protocol) 协议。

RESP是一个支持多种数据类型的序列化协议：简单字符串（Simple Strings）,错误（ Errors）,整型（ Integers）, 大容量字符串（Bulk Strings）和数组（Arrays）。

而区分这些数据类型主要靠的是首字节：

- +：单行字符串（Simple Strings），后接字符串
- -：错误（ Errors），后接错误信息
- :：整形（ Integers），后接数字
- $：大容量字符串（Bulk Strings），后接字符串长度，下行为字符串内容
- *：数组（Arrays），后接数组长度，下一行开始为数组内容

例子：

~~~sh
# 假设我们发送一道命令，下面命令指的是订阅first、second两个频道
> SUBSCRIBE first second
# 那这个命令会被转换成
> *3
> $9
> subscribe
> $5
> first
> :1
> *3
> $9
> subscribe
> $6
> second
> :2
~~~

### Redis的单线程

经常我们会听说redis是单线程，这个说法不全对，但也不全错。

像后面说到的AOF rewrite、RDB bgsave都属于多线程，也就是使用了fork子线程，详细可以看后续持久化章节。

而Redis只在***命令执行处理***以及***网络请求队列处理***上是多线程，我们可以看下图：

![](.\image\QQ截图20240505162128.png)

![](.\image\QQ截图20240505162202.png)

在Redis的命令执行过程中，不存在两个命令同时被处理，而当命令队列爆满的情况下网络请求也会阻塞在网络请求队列，只有命令队列空出位置，网络请求队列中的命令才能进入命令执行队列，从网络请求队列到命令处理队列，就类似一个管道，属于单线程模型。

***那为什么单线程情况下，redis还能这么快呢？***

- 纯内存处理
- 使用非阻塞I/O——epoll多路复用技术，这也是redis实现高并发的方式

### 为什么要使用Redis

我们知道，Redis是一个基于内存的数据库，而其他常规数据库都是将数据存储在硬盘中的，也就是说，在进行数据库操作时，Redis操作的是内存，而其他数据库操作的是硬盘，而内存的运算速度远大于硬盘。所以我们可以想象，Redis最大的一个特点就是快，这也是我们使用Redis的原因。

在许多实际场景中，我们常常会面临高并发问题，或者是http服务提供了过多的接口，而加载一个页面时同时调用太多接口，这些接口都有对常规基于硬盘的数据库进行操作，如果它们操作的是不同的数据库表还好，但若是都集中操作同一个表，倘若表的锁粒度不够细，那么数据库进行硬盘操作的时间成本是非常高的，但是倘若粒度太细，又会过多的消耗性能或者增大实现复杂度，并且还有一个硬伤，就是硬盘操作太慢！总而言之，硬盘数据库不利于应对高并发场景。

而redis内部使用epoll多路复用I/O方案，即使是单线程模式也能高效处理高并发问题。

### Redis的定位

Redis以快著称，但其也有一个根本上的缺点，就是能存的东西太少！因为其是基于内存的数据库，而内存的空间成本是非常大的，所以Redis并不适合作为持久存储的数据库，它的定位就是进行一个过渡，防止高并发影响正常数据库的运作。

所以Redis又被称为缓冲数据库。

## Redis的功能

### 慢查询记录

什么是慢查询？就是某些指令的执行会损耗大量的时间，当这个时间超过一定的阈值，就属于慢查询。

许多存储系统都有提供慢查询记录日志的功能，比如mysql，而redis也提供了这样的功能。

慢查询的发生极大影响程序执行性能，因为redis在网络处理、指令执行都属于单线程，而慢查询的出现会阻塞后续指令的执行，导致整体性能的下降。而通过记录慢查询日志，开发人员可以分析哪些指令存在慢查询，从而找到一定的方法去修复这个问题。

慢查询日志一般由：发生时间、耗时、命令详细信息组成。由下图我们可以知道redis的执行步骤，而慢查询一般只记录步骤3的耗时。

![](.\image\QQ截图20240504162150.png)

前面讲到慢查询有一个阈值，那么这个阈值是多少呢？这就需要根据实际情况去看了，也就是说阈值是可以通过我们自己来设置的。以及我们还需要知道慢查询的日志存放在哪，这两个问题将在下面给出答案。

具体来说，redis.conf提供了两个字段供我们设置阈值和存储规则：

- slowlog-log-slower-than：阈值，单位微秒，默认值10000
- slowlog-max-len：慢查询记录存储最大长度，超出部分遵循fifo算法

从上面两个字段，我们无法看到日志的存储位置，实际上日志是存储在redis中的，我们可以通过下面几个命操作慢查询记录：

- slowlog get [n]：显示日志
- slowlog len：显示日志长度
- slowlog reset：重置日志

日志存储在redis中，就说明日志会随着内存的清理而消失，redis没有提供对其作持久化的功能，但是可以通过第三方脚本去执行，这里就不过多赘述。

### 订阅发布模式

发布订阅的模型如下图所示：

![](.\image\QQ截图20240504165018.png)

redis主要提供了6个指令来实现发布订阅：

- PSUBSCRIBE  [pattern [pattern ...]]：模式订阅，及正则匹配
- PUBLISH [channel [channel ...]]：发布消息
- PUBSUB：用于查看发布与订阅系统状态的命令， 它由数个不同格式的子命令组成
  - pubsub channels [pattern]：查看至少有一个订阅者的频道（活跃频道）
  - pubsub numsub [channel ...]：查看频道订阅数
- PUNSUBSCRIBE  [pattern [pattern ...]]：模式取消订阅
- SUBSCRIBE [channel [channel ...]]：订阅一个或多个频道
- UNSUBSCRIBE [channel [channel ...]]：对一个或多个频道取消订阅

模式订阅和普通订阅订阅到同一个频道时，客户端会接受到频道的消息多次，比如：

```sh
SUBSCRIBE foo
PSUBSCRIBE f*

# 如果有消息发送到foo，那么客户端会接受到两次消息，一个是message类型消息，一个是pmessage类型消息
```

订阅发布模式由于其结构，可以应用于：聊天室、公告、服务解耦。

关于聊天室的例子可以参考[Pieter Noordhuis写的高性能聊天室案例](https://gist.github.com/pietern/348262)，但是遗憾的是，redis的订阅发布并没有提供存储功能，也就是说订阅者无法获取到订阅频道之前的消息，也无法进行消息的回溯，比如撤回功能。所以redis的订阅发布更多还是用来进行服务的解耦，或者简单的响应式场景（一个地方发生改变，其他引用它的地方也做出改变）。要实现更专业的消息队列系统，可以使用[Kafka](https://kafka.apache.org/)、[RocketMQ](https://rocketmq.apache.org/zh/)。

关于消服务解耦，我们可以参考下图：

![](.\image\QQ截图20240504173741.png)



这是一个常规的响应式案例，也就是多个视频服务是依赖于某个视频资源平台的视频资源的，我们只要通过redis来管理视频资源平台（发布者）与视频服务（订阅者）的关系，就可以只通过修改视频管理平台中的视频资源，从而使所有视频服务都进行响应的更改，而不需要对每个视频服务进行操作。

### Pipeline

我们在前面的章节中有提到，Redis在网络处理和命令执行的过程是单线程的，也就是说，Redis接收客户端传来的命令消息时，因为接收消息的过程是单线程的，所以每个消息都是阻塞读取的，这样一来，如果我们处理某个场景的指令消息是一条一条发送给redis的情况下，会额外添加网络传输、消息阻塞的时间成本，如下图：

![](.\image\QQ截图20240504175845.png)

但是我们利用redis的pipeline，就可以把一堆指令封装到一个消息内，统一发送给服务端，这样多个指令只需要进行一次消息传输，只消耗一个来回的网络传输成本，如下图：

![](.\image\QQ截图20240504180323.png)

### 事务

事务简单来说就是遵循ACID机制，一组命令如果其中一个命令出现问题，那么整组命令包括已经执行的结果都将被抛弃，也就是回滚。

Redis多命令执行一般分为两种情况：

- 非事务性流水线（命令组操作的键都是不相关的键）：这个时候就不需要考虑回滚问题，可以使用multi/exec或pipeline封装命令列。
- 事务流水线（命令组操作的键是紧联系的，一个失败其他也不能写入）：Redis提供了几个指令来实现事务：Watch、Multi、Exec、Unwatch、Discard。

Redis事务管理指令的含义：

- Multi：标记一个事务块的开始，之后的命令都会放入队列，并不会立即执行
- Exec：用于执行事务队列中的所有命令
- Watch：用于标记要监视的key，以便有条件地执行事务
- Unwatch：用于取消Watch命令对所有 key 的监视
- Discard：用于取消事务，放弃执行事务队列内的所有命令

Redis事务的执行逻辑：***Redis并没有实现回滚机制***，所以其对客户端执行的命令是保持乐观的，也就是它认为客户端发送的命令不会出现除了***冲突问题***以外的问题，也就是说Redis的***原子性只体现在冲突问题上***，***遇到其他的问题，事务并不会保持原子性***。

Redis不支持原子性的例子：

~~~shell
127.0.0.1:6379> multi
OK
127.0.0.1:6379> sadd user:a:follow user:b
QUEUED
127.0.0.1:6379> zadd user:b:fans 1 user:a
QUEUED
127.0.0.1:6379> exec
1) (integer) 1
2) (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379> sismember user:a:follow user:b
(integer) 1

# 可以看到sadd user:a:follow user:b执行成功了
~~~

Redis命令执行错误有两种：

- 命令错误：命令写错
- 运行时错误
  - 常规错误（比如给了某个键错误格式的值）
  - 冲突问题（只有使用watch的情况才会出现）

常规错误就不说了，说说冲突问题：

![](.\image\QQ截图20240504191749.png)

从上图我们可以看到，我们对key进行修改，客户端-1使用了multi，实际执行是在T6时刻，但是在T3时刻客户端2以及对key进行了操作，可以预见客户端-1希望的结果是“javajedis”，但是如果没有碰撞管理机制（虽然图中有，但读者先假设没有），那么结果将会是“javapythonjedis”。

那么要如何解决冲突问题呢？

Redis利用乐观锁来简单的管理冲突问题，简单来说就是在执行命令之前先查看需要修改的键是否正在被使用，如果没被使用就可以继续执行，否则就报错。可以利用这个实现比较硬核的原子性，也就是监听所有需要修改的键是否正在被使用，如果有被使用的那么就不进入指令。按照Redis的单线程指令执行模型，在提前进行监控后，理论上来说是不会再发生冲突了。

具体实现监控键是否有被使用就是利用WATCH命令，如上图所示，上图在T6时刻会进行报错，get key得到“javapython”

看到这里我们可能会产生以下疑问：

- 既然Redis事务不具备原子性，那为什么还称为事务呢？
- multi/exec和pipeline的区别

问题的解答：

> - 关于第一个问题
>
>   实际上Redis为了贯彻其简单的理念，所以才不设置回滚机制。但其实使用乐观锁就可以解决大部分原子性的问题了，也就是冲突问题，就像上面描述的一样，要不就不执行，要不就执行完，Redis确实做到了。
>
>   但是为什么还说Redis事务不具备原子性能，这是因为除了冲突问题之外，Redis还可能面临其他问题：命令错误问题、key存储格式问题、内存问题等，一旦遇到这些问题，指令执行了一半就会被强制中断，而执行过指令却已经被写入redis了，这才说redis不具备原子性，但redis考虑到其实这种时候作回滚也没什么意义，因为针对以上问题，并不是说数据回滚了重新执行后就不会出现问题了，而是需要进行人工排查的（比如命令错误，发生了是不是需要人工去修改命令？），所以设置回滚也没什么意义。
>
> - 第二个问题
>
>   区别就是multi/exec可以引入watch，然后实现冲突监听，而pipeline则没有这个功能；并且multi/exec如果其中一个指令出现问题，其后续的指令都不会再执行，而pipeline则不管这个问题，即使其中一个指令出错，其他指令也能正常执行。

### 数据持久化

Redis提供了两种方法：快照（RDB）、只追加文件（append-only file,AOF）

#### 快照（RDB）

快照是在指定的时间间隔内生成***数据集的时间点快照***，意思就是快照持久化的是数据。

***如何执行快照***

- 可以通过save指令进行快照：save命令会阻塞Redis主线程，不利于生产环境

- 可以通过bgsave指令进行快照：bgsave通过开辟一个子进程（fork操作）来进行快照，快照操作不会阻塞主线程，fork操作才会阻塞，但是fork操作一般时间很短，具体流程如下图：

  ![](.\image\QQ截图20240504222137.png)

- 可以通过配置redis.conf来控制快照执行方案：

  ~~~sh
  # 表示在每个60秒内至少有1000次键改动时自动转储数据集到磁盘
  # 配置save实际执行的是bgsave指令，快照过程不会阻塞主线程
  save 60 1000
  ~~~

***快照的优点***

- RDB非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心，或者是Amazon S3(可能得加密)
- RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作
- RDB在重启保存了大数据集的实例时比AOF要快

***快照的缺点***

- 不可能实现秒级数据恢复，因为fork属于重量级操作，频繁执行成本过高
- 老版本RDB与新版本RDB不兼容问题

#### AOF

AOF是持久化记录服务器执行的所有***写操作命令***，也就是存储Redis命令。

***如何执行AOF***

aof一般通过redis.conf进行配置：

- appendonly [yes,no]：开启AOF
- appendfilename "appendonly.aof"
- appenddirname "appendonlydir"

- appendfsync [always，everysec，no]：always是每次接收到写入命令后都会立即将数据写入到磁盘，everysec是每秒存一次，no完全依赖操作系统的磁盘缓存来处理数据持久化，***性能损耗依次降低***
- dir [path]：存储路径，与RDB共用

***AOF的优点***

- 当AOF文件变得很大时，Redis会自动在后台进行重写，重写流程如下图：

  ![](.\image\QQ截图20240504231300.png)

- AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储

- 使用AOF Redis会更具有可持久性(durable)

- AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因)，redis-check-aof工具也可以很轻易的修复，但也不是万能的，也可能需要人工审查恢复

***AOF的缺点***

- 对同样的数据集，AOF文件通常要大于等价的RDB文件
- OF可能比RDB慢，这取决于准确的fsync（always\everysec\no）策略

#### Redis启动加载持久化数据的策略

![](.\image\QQ截图20240504231710.png)



#### AOF和RDB使用哪个？

- 一般两个同时使用
- 如果不怕数据丢失分钟级以上，可以只使用RDB
- 单独使用AOF或许会丢失掉RDB方便备份、启动快的特点
- 未来Redis或许会将两者结合成一种持久化方式

### 复制

因为这里涉及到分布式，需要另开一篇文章，这里就只进行一些基础的介绍。

复制是用于设置主从redis服务器的，一般用于解决以下几个问题：

- 高可用性问题，可以参考后续的***高可用性拓展***章节
- 实现分布式redis数据一致性问题

复制方式有：

- 部分复制
- 全量复制

### 集群

因为这里涉及到分布式，需要另开一篇文章，这里就只进行一些基础的介绍。

redis集群原理是将各个key映射到某个数字区间中，而一个数字区间就代表着一个集群，这种做法就能使数据按一定逻辑存储在多个redis服务器上，起到的效果有：

- 数据分布存储，减少每个redis服务器的存储量，减少查询成本
- 可以存储更多数据

分槽逻辑如下图所示：

![](.\image\QQ截图20240505222654.png)

redis集群是redis分布式的实现方案。

### LUA

lua是一个脚本语言，***可以通过lua自定原子命令***，与pipeline和multi/exec不同，lua不是简单的组合命令，而是将命令进行合并，以一条命令的形式出现在redis中，也就是在执行过程享受redis单线程特性，不会被其他命令打扰。

但是虽然是原子命令，由于redis不具备回滚的特性，如果出现执行失败的情况，虽然后续指令都停止执行，但是前面执行过的指令照样会写入redis，这种情况就类似使用multi/exec。具体案例证明可以参考[阿里 P7二面：Redis 执行 Lua，能保证原子性吗？](https://zhuanlan.zhihu.com/p/684155151)

## Redis常见问题

### 阻塞

阻塞是redis单线程模型常会面对的问题，因为命令队列只能依次排队进入，如果某个命令的执行耗时过长，就可能发生阻塞。

那么是什么情况下会导致命令执行时间过长呢？

- 数据结构不合理
- 使用hgetall、getall等操作
- CPU饱和
- 持久化相关堵塞

还有除了命令执行时间过长的原因导致阻塞，这些就属于外在原因了：

- CPU竞争
- 内存交换
- 网络问题

### 缓存雪崩

缓存雪崩是什么？缓存层一般承受着大量请求，有效的保护了存储层，但是如果缓存层的key大量失效或者出于某种原因停止工作了，那么这些大量请求将会直达存储层，这种情况存储层很可能发生崩溃，雪崩原型如下图所示：

![](.\image\QQ截图20240505164633.png)

如何防止雪崩的发生：

- 提高存储层的质量，利用加锁或者队列的方式限制访问量
- 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期，但这种情况会消耗大量内存
- 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

### 缓存穿透

在一般缓存-存储设计架构中，我们会先查询缓存，如果缓存中没有key则在查存储层。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透，如下图：

![](.\image\QQ截图20240505165300.png)

那要如何解决这个问题呢？

- 设置空缓存，如下图：

  ![](.\image\QQ截图20240505165352.png)

- 设置布隆过滤器（Bitmap）拦截，如下图：

  ![](.\image\QQ截图20240505165548.png)

### 无底洞优化

2010年，Facebook的Memcache节点已经达到了3000个，承载着TB 级别的缓存数据。但开发和运维人员发现了一个问题，为了满足业务要求添加了大量新Memcache节点，但是发现性能不但没有好转反而下降了，当时将这种现象称为缓存的“无底洞”现象。

简单来说就是增加集群Redis并不能使Redis查询速度加快。

原因为：

- 客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大
- 网络连接数变多，对节点的性能也有一定影响

## Redis使用策略

### 稳定性策略

要制作稳定性策略，首先我们需要明白哪些情况会使Redis的运行不稳定：

- 数据安全威胁
  - Redis会被外部连接上
  - Redis传输过程中被数据被获取
- 哈希碰撞攻击
- 内存不合理分配
- Redis服务器不正常停止（高可用性拓展）

#### 数据安全威胁

***Redis会被外部连接上***

有时候在开发过程中，我们为了图方便会直接把redis暴露在外网中，这种做法是非常危险的，因为redis没有显式的密码设置，所以外部是可以轻易访问到你的redis服务器的，这样数据安全就是去了保障，并且可能会被进行各种降低性能的攻击。

一般来说，对于这种情况我们有四种解决方法：

- 设置防火墙

- 只绑定到内网

  ~~~sh
  # redis.conf配置
  bind 127.0.0.1
  ~~~

- 设置连接密码

  ~~~sh
  # redis.conf配置
  requirepass mypassword
  # 密码需要足够长，不然会被轻易的进行暴力破解
  ~~~

- 禁用特定危险命令

  ~~~sh
  # 将命令改名
  rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
  ~~~

***Redis传输过程中被数据被获取***

目前redis还没提供ssl加密，因为有这样需求的用户很少，我们可以使用第三方工具[Spiped](http://www.tarsnap.com/spiped.html)进行redis传输中的SSL加密，当然这也是使用在Redis会被外网访问的情况下的。

#### 哈希碰撞攻击

说哈希碰撞攻击时，我们先简单理解一下hash的碰撞机制：

我们都知道hash是通过一串字符串经过一定的算法得到的，而这个字符串将作为某个value的唯一标识，理论上来说，我们要得到某些值，只需要O(1)的执行时间，但是如果碰到两个hash一样的情况，这个值会顺延现存的value的位置往后进行存储，这个顺延的位置称为桶，如下图所示：

![](.\image\QQ截图20240505173141.png)

当然也有其他存储方式，比如红黑树，但是不可否认，数据查找的效率变低了，比如桶变成O(n)，红黑树是O(logn)。

而攻击者可能就会使用某些特殊指令使查找效率达到最坏的O(n)的情况，也就是制造碰撞hash。

***Redis内部解决***

为了阻止这种攻击，Redis对于散列函数使用了一个预执行的伪随机数种子。

Redis使用了qsort 算法实现了**SORT**命令。当前，这个算法不是随机的，因此存在因特定输入触发产品最坏情况的可能。

#### 内存不合理分配

redis是基于内存的数据库，所以对于内存的使用必须要谨慎，因为内存是不稳定的，如果内存占用达到上限，可能会造成：

- 操作系统字段内存清理策略，导致数据丢失
- redis阻塞，甚至宕机
- 影响其他服务的运行

那么我们应该如何管理好内存分配呢？

***要管理好内存分配，首先需要知道redis的内存消耗在哪些方面。***

redis提供了`info memory`命令来查看redis的内存消耗，下图是info memory所得到参数的含义：

![](.\image\QQ截图20240505205759.png)

其中used_memory分为以下几个部分：

![](.\image\QQ截图20240505205956.png)

- 对象内存：表示用户数据

- 缓冲内存：表示客户端缓冲、复制积压缓冲、AOF缓冲

- 内存碎片：Redis默认的内存分配器采用jemalloc，可选的分配器还有：glibc、tcmalloc。以jemalloc为例，它的分配规则大概是这样：

  ![](.\image\QQ截图20240505210251.png)

  这种分配方式就会造成许多内存碎片，比如某个文件4.1MB，那么他就会存在8MB的空间中，那么就浪费了3.9MB。

***理解了内存消耗方式后，下面来说说策略***

我们知道内存消耗原理后，就会知道内存不合理分配方式是在什么时候发生的了，比如文件大小处于临界，那么就会造成内存碎片化；还有就是在使用AOF\RDB时造成的大量缓冲内存浪费；以及不合理的value值导致的对象内存过大。

那么我们要如何处理这些问题呢？

- 关于处理内存碎片：数据对其、安全重启

- 关于AOF\RDB操作：关闭THP、设置sysctl vm.overcommit_memory=1

- 关于对象内存进行value值合理设置：

  - 关于redisObject，也就是value的存储格式如下图：

    ![](.\image\QQ截图20240505212022.png)

  - 具体我们可以进行：缩减键值对象、共享对象池、字符串优化、编码优化、控制键数量等操作。

- 除了上面比较针对性的方法之外，还有就是从整体上进行内存使用的控制：

  - redis.conf中配置maxmemory，或者动态调整maxmemory
  - 调整内存溢出策略，redis.conf配置maxmemory-policy：
    - noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息
    - volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直到腾出足够空间为止。
    - allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
    - allkeys-random：随机删除所有键，直到腾出足够空间为止。
    - volatile-random：随机删除过期键，直到腾出足够空间为止。
    - volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。

关于内存的处理，本篇文章只列出了一些比较浅的东西，也就是给了思路，具体实践方法可以阅读[《redis开发与运维》](https://awesome-programming-books.github.io/redis/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4.pdf)

#### Redis服务器不正常停止（高可用性拓展）

redis服务因为是基于内存的，所以十分不稳定，如果redis服务突然宕机了，会对我们的服务造成很大的影响：

- 缓存雪崩
- 数据丢失
- 服务中断

那么我们就会思考，当redis服务宕机时，我们是否能使用备份redis服务器来顶替呢？从而减轻其带来的危害。

***Redis通过哨兵机制可以实现这个目标***

哨兵用于管理多台redis服务，如果某台出现问题会自动上位某个辅组redis服务，从而不影响应用的运行。具体会在以后的文章中介绍。

### 存储实践

我们在使用redis的过程中，通常会搭配硬盘数据库（mysql），那么怎样的搭配策略是合适的呢？

- 数据体量小的

   对于数据体量小的，我们可以全部做持久化存储在redis数据库中，这样再查数据的情况下就不必再查硬盘数据库了，但是要记住在数据修改时要记住修改redis内的数据。至于还需不需要存进硬盘数据库，这个需要根据实际情况定夺

- 数据体量大的

  对于体量比较大的数据，我们就不能全部存储在redis中了，通常情况下使用的是硬盘数据库写回模型来进行存储，也就是如果redis中命中key，则直接从redis中取数据，如果没命中则从硬盘数据库中取数据并且将数据写回redis，之后再取数据就可以从redis中取了，可以参考缓存穿透章节中的写回空数据的流程图。这种情况需要考虑的问题就多了：

  - 热点key问题，哪些key应该存，哪些key不应该存，这对内存分配有很大的影响
  - 数据一致性问题

  热点key问题这里就不提了，这是根据实际情况来操作的，主要说说数据一致性问题，在分散两个存储器的情况下，我们要如何保障数据一致性呢？在计算机原理cache和硬盘的数据一致性保持逻辑中就有提出三种策略：

  - Cache Side

    直接更新硬盘数据，然后删除缓存数据，缓存依赖再次读取硬盘数据时写回

  - Write Through

    同时更新缓存和硬盘

  - Write Behind

    先写缓存，到合适的时机再写硬盘，通常在高并发情况下使用

  更具体可以参考[高并发场景下，到底先更新缓存还是先更新数据库？](https://mp.weixin.qq.com/s/bewlUcHL2e6fw2vDrhEDCw)

## 一些小坑

### 明明设置不过期的键，为什么会离奇消失？

我们在实际使用redis，可能会遇到明明键是不过期的，但是过段时间它就消失了，这种情况是因为操作系统的内存自动清理机制导致的。

如何解决？

设置持久化存储。

## 参考

[《redis开发与运维》](https://awesome-programming-books.github.io/redis/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4.pdf)

[redis中文文档](https://redis.com.cn/documentation.html)

[高并发场景下，到底先更新缓存还是先更新数据库？](https://mp.weixin.qq.com/s/bewlUcHL2e6fw2vDrhEDCw)

[阿里 P7二面：Redis 执行 Lua，能保证原子性吗？](https://zhuanlan.zhihu.com/p/684155151)
