## CSS经典面试题

### 1.盒子快速居中

> 父元素设置display: flex，子元素设置margin: auto

### 2.padding与margin的不同

> 作用对象不同，padding是针对自身，margin是作用于外部对象

### 3.vw与百分比的区别

> vm是相对于视口，百分比是相对与父元素

### 4.如何让浏览器支持小字体

> 浏览器字体小于一定px就会不再减小，谷歌以12px为界
>
> 使用transform: scale()
>
> 注意：tranform只针对块盒和行块盒有效，所以对span需要先进行块盒转换

### 5.吸附效果

> position: sticky
>
> 可以完成列表滚动时，标题吸附在顶部，需要搭配top值使用
>
> 即top值达到规定值时会有吸附效果
>
> 原理：设置了该属性的元素的top值指的是该元素顶部相对设置了overflow属性包含块的距离，如果父元素没有会依次往上找，直到找到视口，也就是祖先元素没有设置overflow的话，最后会根据视口来确定吸附的位置
>
> 失效的解决方法：给相应的父元素设置overflow属性

### 6.渐变

> 渐变分为：
>
> - 锥形渐变：以圆心从某个角度开始，绕圆一周渐变，conic-gradient()
>
>   <img src=".\images\QQ截图20230822143832.png" style="zoom:50%;" />
>
> - 线性渐变：linear-gradient()
>
> - 径向渐变

### 7.弹幕不遮挡人像

> 解决方案：使用mask-image属性添加遮罩

### 8.复合属性BUG

> 我们在页面中使用样式时，常常会有失效的情况，这个时候可能就是复合属性造成的
>
> 原理：当我们使用复合属性时，指定了一些样式，比如background: url(...)，虽然我们没书写其他属性，但是当我们使用了复合属性后就会自动把其他属性也书写了，只是值是默认的，如果我们想再设置自定义属性时，可能就因为权重的问题而不生效
>
> 技巧：复合属性在F12里有黑色小三角标识

### 9.背景模糊效果

> backdrop-filter: blur()，可以实现毛玻璃效果
>
> 功能就是该属性会作用于压住的所有元素

### 10.文字描边效果

> 使用text-stroke

### 11.瀑布流布局

> 先使用grid布局，确定好列的个数和大小，然后给行加上属性grid-template-rows: masonry

### 12.拖动效果

> 元素添加draggable属性

### 13.保持图片清晰度

> background: image-set() 可以设置多张图片，以及图片对应的DPR(设备像素比)，当DPR改变时会自动切换对应的图片，完成清晰度保持
>
> DPR = 放大倍数/物理像素

### 14.交融效果

> 通过设置filter属性中的blur和contrast(对比度)属性，contrast添加在父元素，blur添加在子元素

## JS经典面试题

### 1.深浅拷贝

> 浅拷贝只是拷贝到变量内的值，如果是高级数据类型，变量内部存的是地址，那么浅拷贝也只拷贝到地址
>
> 深拷贝的话，会将高级数据类型内的值完全拷贝，即将地址内部所存的值都拷贝
>
> 实际上深浅拷贝都是指高级数据类型，对于简单数据类型的交换数据只能称为赋值
>
> 实现深拷贝的三种方法：
>
> - lodash
> - JSON.toString&&JSON.parse
> - 自己写一个函数

~~~javascript
//自己写深拷贝递归函数
function deepClone(source){
    const target = source.constructor === Array ? [] : {}
    for(let key in source){
        //判断该属性是不是属于原对象/数组的属性
        if(source.hasOwnProporty(key)){
            //如果是数组则进入递归
        	if(source[key] && typeof source[key] === Array) {
                const target[key] = source[key].constructor === Array ? [] : {}
                target[key] = deepClone(source[key])
            }
            //如果是对象则进入递归
        	if(source[key] && typeof source[key] === Object) {
                const target[key] = source[key].constructor === Array ? [] : {}
                target[key] = deepClone(source[key])
            }
            //否则直接赋值
        	target[key] = source[key]
        }
    }
    return target
}
~~~

### 2.this指向问题

> - this一般都是针对函数（方法、构造函数、普通函数）来说的，对象是没有this的
> - 外层this指向window
> - 普通函数内部的this指向调用者，this在声明函数的时候不会定义，只有被调用的时候才定义
> - 而普通函数有两种情况
>   - 对象内方法：this指向实例化对象，多级对象嵌套的情况this指向最近的调用者
>   - 通过fn()直接调用：this指向window，因为实际上就是window.fn()
> - 箭头函数在声明函数时就定义好this了，this的值为沿用上一层函数作用域下的this
>   - 这也是我们很容易出错的点，比如对象内部使用了箭头函数，我们想当然的认为沿用上一层this那就是上一层的对象
>   - 实际上对象是不会创建this的，所以它会一直向上找到一个函数作用域下的this
>   - 于是它只能找到window创建的函数，所以this才等于window

### 3.闭包

> - 为什么要有闭包
>   - 避免变量被污染
>   - 数据私有化
>   - 保存变量，常驻内存
> - 什么是闭包
>   - 一个函数内部嵌套另一个函数
>   - 嵌套函数调用被嵌套函数的变量
>   - 嵌套函数被返回并被外部接收
> - 闭包的原理
>   - JS垃圾回收机制是标记清除法，对不能访问到的变量进行内存回收
>   - 而返回出来的函数被外部变量接收，函数内部的值能一直被访问到，所以不会被回收

### 4.new的过程

~~~javascript
const person = new Person()

//1.创建一个对象
const obj = new Object()
//2,创建_proto_
obj._proto_ = Person.prototype
//3.修改this指向
const result = Person.call(obj)
//4.判断返回值类型，构造函数默认返回对象
if(typeof result === 'object'){
    person = result
}else {
    person = obj
}
~~~

### 5.事件委托

~~~html
<ul id = "root">
	<li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
</ul>
~~~

~~~javascript
//事件委托实际上就是借助事件处理的特性----事件冒泡来对多个子元素进行事件添加
//我们获取到父元素
const ul = document.querySelector('ul')
ul.addEventListener('click',(e)=>{
    //点击子元素，由于冒泡，会触发到父元素的事件
    //这时我们就可以监听父元素来代替监听子元素
    if(e.target.nodeName === 'Li'){
        //e.target可以拿到子元素的DOM节点，这时我们就可以对子元素进行操作了
        e.target.style.backgroundColor = 'red'
    }
})
~~~

### 6.setInterval

> setInterval并不总是按照设置的间隔执行，当切换画面之后，浏览器为了保证性能，通常会将setInterval的间隔设置为最少1s
>
> 通常我们做一个游戏使用到定时器，如果切换页面后，因为这个问题通常会出现一些bug，如何解决这个问题呢？
>
> 解决方法：监听visibilitychange事件，可以根据document.visibilityState得到页面状态，hidden时将游戏暂停

### 7.页面内定位

> 页面定位有3种方法：
>
> - 通过计算得到滚动距离，缺陷：计算麻烦
> - 设置id，然后通过url地址的hash(#)定位，缺陷：只适用整体页面的定位，不适用于某个盒子内部的定位，并且和框架冲突
> - 通过API - element.scrollIntoView()

### 8.避免输入中文触发input事件

> 问题描述：在输入中文的过程中，input事件会被无意义的触发
>
> 解决方法：监听compositionstart、compositionend事件，表示监听合成文字的开始和结束，设置一个搜索flag，一开始设置为false，compositionstart设置为true，这时候就不要进行搜索，compositionend再设置为false

### 9.Math.floor()和Math.parseInt()的区别

> Math.floor()向下取整
>
> Math.parseInt()向零方向取整
>
> 对于正数可能没什么区别，但是对于负数，Math.floor()往小取，Math.parseInt()往大取

### 10.对象添加私有属性

> 以前只能使用symbol进行私有字段的定义，非常麻烦，很多人都已"_"开头进行命名来代表私有字段，如：\_abc，但是这样并不在程序编译上具有效力，只是进行一个私有声明而已，外部任然能够访问，现在官方添加了一种新的命名方式来创建私有属性：#
>
> 添加私有属性的方法：
>
> - #:命名前缀，比如#abc
> - symbol

### 11.期望参数

~~~javascript
function A(a,b){}
function B(a,b=1){}
function C(a,...rest){}
console.log(A.length)  //2
console.log(B.length)  //1
console.log(C.length)  //1
//对函数使用length，得到的是期望参数的个数
~~~

### 12.commonJS的require

> 对于require函数，他的底层原理就是：将模块文件内的代码放到一个函数内执行，然后创建了一个module.export，令exports、this的值为module.export的地址，如果在代码中不改变exports、this的指向，中间不论是给这三个中的哪个对值进行添加，最终都能被导出来，但如果改变了指向，因为require代码返回的是module.export，所以结果就和exports、this没关系了

### 13.复制限制功能

> 监听copy事件，当复制发生时会触发，禁用默认行为就可以防止复制
>
> 阻止默认行为后，可以通过e.clipboardData.setData()设置用户复制的文本内容，通常会给一些提示

### 14.判断传入函数是否标记async

> async函数在原型上有Symbol.toStringTag属性（知名符号）,Symbol.toStringTag=AsyncFunction
>
> Symbol.toStringTag是ES6新增的，可以用于改变Object.prototype.toString()返回结果的后半部分
>
> 因此可以通过这个方法进行判断

~~~javascript
const asyncFn = async ()=>{}
console.log(Object.prototype.toString.call(asyncFn)) //'[Object AsyncFunction]'
~~~

### 15.对象赋值技巧

~~~javascript
//假设我们要将一个变量的内容当作一个对象的键值
const name = '333'
const obj = {
    //这样写显然是错误的
    name: 1
}
//只能得到 obj.name=1，我们想要的效果是obj.333=1
//解决方法
const obj = {
    [name]: 1
}
~~~

### 16.await的一些点

> 对于await，它会根据右边返回的promise的状态来判断完成情况，如果promise的状态没完成，它会一直等
>
> 但是如果右边返回的不是promise，它就不会进行等待，比如以下例子
>
> await后的函数实际上就被放入微队列

~~~javascript
async function a() {
    await setTimeout(() => {
                console.log(222)
            }, 0)  //执行setTimeout是将回调放入计时队列然后就结束
    console.log(1111)
}

async function b() {
    await (async () => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log(222)
                resolve()
            }, 0)
        })
    })()
    console.log(1111)
}
a() //输出1111 222
b() //输出222 1111
~~~

### 17.[Symbol.interator]与generator

> [Symbol.interator]是一个接口，用于实现对象的迭代，可以通过将generator赋值给[Symbol.interator]实现这个接口
>
> 然后我们就可以通过for...of...去遍历对象了

## 优化相关

### 1.在浏览器中输入URL并回车后都发生了什么

> - DNS解析成IP地址（以www.baidu.com为例）
>   - 根域找到com的域名服务器IP地址（顶级域名服务器）
>   - com的域名服务器地址找到baidu.com的域名服务器IP地址（二级域名服务器）
>   - baidu.com的域名服务器地址找到www.baidu.com的IP地址（三级域名服务器/权限域名服务器）
>   - 返回到本地，本地进行缓存
> - 请求IP地址（tcp建立连接：三次握手）
>   - 客户端发送syn=1,agreeack=x的包请求连接
>   - 服务器回复syn=1,ack=x+1,agreeack=y的包表示确认连接
>   - 客户端回复syn=0,ack=y+1的包表示连接建立
>
> - 取得数据
> - 断开tcp连接（四次挥手）
>   - 客户端发送fin=1,agreeack=x的包请求断开连接
>   - 服务器发送ack=x+1的包表示数据传输完成
>   - 服务器发送fin=1,agreeack=y的包表示请求断开连接
>   - 客户端发送ack=y+1断开连接

### 2.性能优化的几个方面（概念）

- 页面加载性能（加载事件，用户体验）
- 动画与操作性能（是否流畅无卡顿）
- 内存占用（内存占用过大，浏览器崩掉等）
- 电量消耗（游戏方面，前端可不考虑）

### 3.日常开发，从哪些点做性能优化（实际做法）

> - 加载
>   - 减少http请求（精灵图，文件的合并）
>   - 减小文件大小（资源压缩->图片压缩、视频压缩、代码压缩）
>   - CDN（第三方库）->大文件、大图通过可靠第三方库链接引入
>   - SSR服务端渲染，预渲染
>   - 懒加载
>   - 分包
> - 性能
>   - 减少dom操作，避免回流，有操作量很大的dom可以采用文档碎片的方法

<img src=".\images\QQ截图20230704203532.png" />

### 4.懒加载

~~~html
<body>
    <!-- timg.gif是加载动画，time.jpg才是真实图片 -->
    <img src="./img2/timg.gif" data-src="./img2/time.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time2.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time3.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time4.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time5.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time6.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time7.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time8.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time9.jpg" alt="">
</body>
~~~

~~~javascript
let num = document.querySelectorAll('img').length
let imgs = document.querySelectorAll('img')
lazyLoad()
window.onscroll = lazyLoad
let n = 0
function lazyLoad(){
    let seeHeight = document.documentElement.clientHeight
    let scrollTop = document.documentElement.scrollTop
    for(let i=n;i<num;i++){
        if(imgs[i].offsetTop < seeHeight + scrollTop){
            if(imgs[i].src === "./img2/timg.gif"){
                imgs[i].src=imgs[i].dataset.src
            	n++
            }
        }
    } 
}
~~~

### 5.长任务优化问题

> 首先补一点前置知识：
>
> 浏览器渲染的过程
>
> - 解析html
>   css为预解析，不会阻塞浏览器渲染主线程
>   js会改变dom，所以会阻塞主线程	
>
> - 计算样式
>
> - layout
>
> - 分层
>
> - 绘制
>
> - 分块
>
> - 光栅化
>
> -  画
>
>   **最后两步交给gpu线程执行**
>
> 由此可以解释：
> 假设我们有一个动画，如果动画的运动是通过margin和left来实现的，那么我们执行js代码时，会阻塞动画的运行，因为动画每16.6ms都会从layout开始进入主线程渲染，而js会阻塞主线程的渲染
> 但是我们使用transform来实现动画时，js的执行并不会阻塞动画的渲染，因为transform是在gpu运行的
>
> requestAnimationFrame(callback) API表示下次渲染执行之前调用callback，我们可以用它来实现动画：
> 比如我们修改了某元素的计算样式值，但js没执行完并不会讲该结果加入渲染主线程，这时紧接着再给最终位置，是达不到预想效果的，这时候使用requestAnimationFrame就达到效果
> 原理：第一次设置位置时有了一个渲染任务，然后再进入渲染之前requestAnimationFrame执行了callback，这样又有一个渲染任务，所以在主线程中总共两个渲染任务，有了变化就能实现动画了

~~~javascript
//假设task执行一次耗时5ms，那连着执行1000次就为一个长任务，这样会阻塞动画的渲染
//因为动画渲染的频率是60hz，也就是每16.6ms要执行 -- js->计算样式->layout->绘制等，如果加入长任务，就会推后渲染任务的执行
//这时候我们可以利用requestAnimationFrame的回调特性：在下次渲染前执行，这样我们可以通过Date.now()计算出两次渲染过程的间隔时间，如果间隔时间小于16.6的话，就让task执行，否则让他继续进入下一个渲染周期
//实际上以下写法最坏的渲染周期为16.6+5，但肉眼已经看不出卡顿了，如果设置的更小就进不去true分支了
function _rantask(task) {
        let start = Date.now()
        requestAnimationFrame((time) => {
            if (Date.now() - start < 16.6) {
                task()
            } else {
                _rantask(task)
            }
        })
}
//这是牺牲内存换取体验的方式
~~~

## 架构相关

### 1.使用匿名自执行函数

~~~javascript
//好处：
//1.自执行
//2.防止全局污染
(function(window){
	
})(window)
~~~

### 2.手写jquery

~~~javascript
let $ = jQuery = (function(window){
    let Jquery = function(nodeSelector){
        this.nodes = document.querySelectorAll(nodeSelector)
    }
    Jquery.prototype = {
        each(callback){
            for(let i=0;i<this.length;i++){
                callback.call(this,i,this.nodes[i])
            }
        },
        addClass(classes){
            let className = classes.split(' ')
            className.forEach(item => {
          		this.each(function(index,node){
                    node.classList.add(item)
                })      
            })
        },
        setText(text){
            this.each(function(index,node){
                node.innerText = text
            })
        },
    }
    return function(nodeSelector){
        return new Jquery(nodeSelector)
    }
})(window)
~~~

### 3.VUE底层原理

> - MVVM与MVC的区别
>
>   - MVC中的控制器不能存储数据，所以做不到前后端分离，因为前端总会依赖后端的数据，没有后端传来的数据就不能工作
>   - 而MVVM中视图模型有自己的临时存储数据的地方，所以即使后端不传来数据，也可以进行工作
>
> - v-model的实现原理
>
>   ~~~html
>   <input type="text" id="username">
>   <div id="text"></div>
>   ~~~
>
>   ~~~javascript
>   //通过使用Object.defineProperty
>   //getElementById动态监听dom节点
>   const input = document.getElementById('username')
>   const text = document.querySelector("text")
>   const obj = {}
>   Object.defineProperty(obj,'a',{
>       get(){
>   		text.innerText = input.value
>           return input.value
>       },
>       set(value){
>           input.value = value
>       }
>   })
>   
>   ~~~
>

### 4.父子之间v-model问题

> 当我们父组件给子组件绑定了v-model属性，子组件再通过v-model调用该属性时，会打破单向传值（即子组件修改了props）
>
> 要如何解决这个问题呢？

~~~javascript
//setup内部
const props = defineProps(['modelValue'])
const emits = defineEmits(['update:modelValue'])
//我们可以通过计算属性解决这个问题
const model = computed(()=>{
    return new Proxy(props.modelValue,{
        get(){
            return props.modelValue
        }
        set(obj,name,val){
           	emits('update:modelValue',{
                ...obj,
                [name] : val
            })
            return true
        }
    })
})
~~~

## VUE

### 1.为什么要使用虚拟DOM

> 我们以前进行响应式页面渲染的时候，都是设计一个render函数，如果有数据发生改变，就执行这个render函数，而这个render函数通常是将整个页面都进行渲染，这样的作法显然是效率低下的，因为dom节点是一个非常复杂的对象，对这样一个对象进行遍历或者更新都是非常耗时的
>
> 这时候虚拟dom的优势就体现了，虚拟dom是用对象表示的简介的dom节点，有dom节点的必要信息，我们数据发生改变时先进行虚拟dom的更新，然后根据更新的位置去更新相应的真实dom，这样就避免了对整个页面进行渲染，也就提升了效率。其原理照样是对整个页面的dom进行遍历，只不过遍历的是虚拟dom
>
> 但是虚拟dom的使用毕竟是有一个中间过程，如果我们实现响应式不是通过对整个页面进行渲染，而是找到对应的地方进行真实dom操作，这个效率无论如何都是比虚拟dom高的，但是要达到这种理想状态显然是不可能的，因为你不可能知道这个数据对应的真实dom有哪些
>
> 总的来说，虚拟dom还是必要的，这样能够按需更新真实dom，避免了对整个页面进行重复渲染，只不过是多了一个虚拟dom更新的过程
>
> 因此浏览器渲染效率很大程度上是由虚拟dom的对比决定的，一个优秀的diff算法能有效的提高渲染效率

