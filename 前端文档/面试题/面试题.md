## CSS经典面试题

### 1.盒子快速居中

> 父元素设置display: flex，子元素设置margin: auto

### 2.padding与margin的不同

> 作用对象不同，padding是针对自身，margin是作用于外部对象

### 3.vw与百分比的区别

> vm是相对于视口，百分比是相对与父元素

### 4.如何让浏览器支持小字体

> 浏览器字体小于一定px就会不再减小，谷歌以12px为界
>
> 使用transform: scale()

## JS经典面试题

### 1.深浅拷贝

> 浅拷贝只是拷贝到变量内的值，如果是高级数据类型，变量内部存的是地址，那么浅拷贝也只拷贝到地址
>
> 深拷贝的话，会将高级数据类型内的值完全拷贝，即将地址内部所存的值都拷贝
>
> 实际上深浅拷贝都是指高级数据类型，对于简单数据类型的交换数据只能称为赋值
>
> 实现深拷贝的三种方法：
>
> - lodash
> - JSON.toString&&JSON.parse
> - 自己写一个函数

~~~javascript
//自己写深拷贝递归函数
function deepClone(source){
    const target = source.constructor === Array ? [] : {}
    for(let key in source){
        //判断该属性是不是属于原对象/数组的属性
        if(source.hasOwnProporty(key)){
            //如果是数组则进入递归
        	if(source[key] && typeof source[key] === Array) {
                const target[key] = source[key].constructor === Array ? [] : {}
                target[key] = deepClone(source[key])
            }
            //如果是对象则进入递归
        	if(source[key] && typeof source[key] === Object) {
                const target[key] = source[key].constructor === Array ? [] : {}
                target[key] = deepClone(source[key])
            }
            //否则直接赋值
        	target[key] = source[key]
        }
    }
    return target
}
~~~

### 2.this指向问题

> - this一般都是针对函数（方法、构造函数、普通函数）来说的，对象是没有this的
> - 外层this指向window
> - 普通函数内部的this指向调用者，this在声明函数的时候不会定义，只有被调用的时候才定义
> - 而普通函数有两种情况
>   - 对象内方法：this指向实例化对象，多级对象嵌套的情况this指向最近的调用者
>   - 通过fn()直接调用：this指向window，因为实际上就是window.fn()
> - 箭头函数在声明函数时就定义好this了，this的值为沿用上一层函数作用域下的this
>   - 这也是我们很容易出错的点，比如对象内部使用了箭头函数，我们想当然的认为沿用上一层this那就是上一层的对象
>   - 实际上对象是不会创建this的，所以它会一直向上找到一个函数作用域下的this
>   - 于是它只能找到window创建的函数，所以this才等于window

### 3.闭包

> - 为什么要有闭包
>   - 避免变量被污染
>   - 数据私有化
>   - 保存变量，常驻内存
> - 什么是闭包
>   - 一个函数内部嵌套另一个函数
>   - 嵌套函数调用被嵌套函数的变量
>   - 嵌套函数被返回并被外部接收
> - 闭包的原理
>   - JS垃圾回收机制是标记清除法，对不能访问到的变量进行内存回收
>   - 而返回出来的函数被外部变量接收，函数内部的值能一直被访问到，所以不会被回收

### 4.new的过程

~~~javascript
const person = new Person()

//1.创建一个对象
const obj = new Object()
//2,创建_proto_
obj._proto_ = Person.prototype
//3.修改this指向
const result = Person.call(obj)
//4.判断返回值类型，构造函数默认返回对象
if(typeof result === 'object'){
    person = result
}else {
    person = obj
}
~~~

### 5.事件委托

~~~html
<ul id = "root">
	<li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
</ul>
~~~

~~~javascript
//事件委托实际上就是借助事件处理的特性----事件冒泡来对多个子元素进行事件添加
//我们获取到父元素
const ul = document.querySelector('ul')
ul.addEventListener('click',(e)=>{
    //点击子元素，由于冒泡，会触发到父元素的事件
    //这时我们就可以监听父元素来代替监听子元素
    if(e.target.nodeName === 'Li'){
        //e.target可以拿到子元素的DOM节点，这时我们就可以对子元素进行操作了
        e.target.style.backgroundColor = 'red'
    }
})
~~~





## 优化相关

### 1.在浏览器中输入URL并回车后都发生了什么

> - DNS解析成IP地址（以www.baidu.com为例）
>   - 根域找到com的域名服务器IP地址（顶级域名服务器）
>   - com的域名服务器地址找到baidu.com的域名服务器IP地址（二级域名服务器）
>   - baidu.com的域名服务器地址找到www.baidu.com的IP地址（三级域名服务器/权限域名服务器）
>   - 返回到本地，本地进行缓存
> - 请求IP地址（tcp建立连接：三次握手）
>   - 客户端发送syn=1,agreeack=x的包请求连接
>   - 服务器回复syn=1,ack=x+1,agreeack=y的包表示确认连接
>   - 客户端回复syn=0,ack=y+1的包表示连接建立
>
> - 取得数据
> - 断开tcp连接（四次挥手）
>   - 客户端发送fin=1,agreeack=x的包请求断开连接
>   - 服务器发送ack=x+1的包表示数据传输完成
>   - 服务器发送fin=1,agreeack=y的包表示请求断开连接
>   - 客户端发送ack=y+1断开连接

### 2.性能优化的几个方面（概念）

- 页面加载性能（加载事件，用户体验）
- 动画与操作性能（是否流畅无卡顿）
- 内存占用（内存占用过大，浏览器崩掉等）
- 电量消耗（游戏方面，前端可不考虑）

### 3.日常开发，从哪些点做性能优化（实际做法）

> - 加载
>   - 减少http请求（精灵图，文件的合并）
>   - 减小文件大小（资源压缩->图片压缩、视频压缩、代码压缩）
>   - CDN（第三方库）->大文件、大图通过可靠第三方库链接引入
>   - SSR服务端渲染，预渲染
>   - 懒加载
>   - 分包
> - 性能
>   - 减少dom操作，避免回流，有操作量很大的dom可以采用文档碎片的方法

<img src=".\images\QQ截图20230704203532.png" />

### 4.懒加载

~~~html
<body>
    <!-- timg.gif是加载动画，time.jpg才是真实图片 -->
    <img src="./img2/timg.gif" data-src="./img2/time.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time2.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time3.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time4.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time5.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time6.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time7.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time8.jpg" alt="">
    <img src="./img2/timg.gif" data-src="./img2/time9.jpg" alt="">
</body>
~~~

~~~javascript
let num = document.querySelectorAll('img').length
let imgs = document.querySelectorAll('img')
lazyLoad()
window.onscroll = lazyLoad
let n = 0
function lazyLoad(){
    let seeHeight = document.documentElement.clientHeight
    let scrollTop = document.documentElement.scrollTop
    for(let i=n;i<num;i++){
        if(imgs[i].offsetTop < seeHeight + scrollTop){
            if(imgs[i].src === "./img2/timg.gif"){
                imgs[i].src=imgs[i].dataset.src
            	n++
            }
        }
    } 
}
~~~

## 架构相关

### 1.使用匿名自执行函数

~~~javascript
//好处：
//1.自执行
//2.防止全局污染
(function(window){
	
})(window)
~~~

### 2.手写jquery

~~~javascript
let $ = jQuery = (function(window){
    let Jquery = function(nodeSelector){
        this.nodes = document.querySelectorAll(nodeSelector)
    }
    Jquery.prototype = {
        each(callback){
            for(let i=0;i<this.length;i++){
                callback.call(this,i,this.nodes[i])
            }
        },
        addClass(classes){
            let className = classes.split(' ')
            className.forEach(item => {
          		this.each(function(index,node){
                    node.classList.add(item)
                })      
            })
        },
        setText(text){
            this.each(function(index,node){
                node.innerText = text
            })
        },
    }
    return function(nodeSelector){
        return new Jquery(nodeSelector)
    }
})(window)
~~~

### 3.VUE底层原理

> - MVVM与MVC的区别
>
>   - MVC中的控制器不能存储数据，所以做不到前后端分离，因为前端总会依赖后端的数据，没有后端传来的数据就不能工作
>   - 而MVVM中视图模型有自己的临时存储数据的地方，所以即使后端不传来数据，也可以进行工作
>
> - v-model的实现原理
>
>   ~~~html
>   <input type="text" id="username">
>   <div id="text"></div>
>   ~~~
>
>   ~~~javascript
>   //通过使用Object.defineProperty
>   //getElementById动态监听dom节点
>   const input = document.getElementById('username')
>   const text = document.querySelector("text")
>   const obj = {}
>   Object.defineProperty(obj,'a',{
>       get(){
>   		text.innerText = input.value
>           return input.value
>       },
>       set(value){
>           input.value = value
>       }
>   })
>     
>   ~~~
>
>   
