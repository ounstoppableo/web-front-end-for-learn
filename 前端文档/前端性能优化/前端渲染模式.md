### 导读

在前端发展历史中，出现了很多内容渲染的方式，从早期的php服务侧渲染，再到如今基于vue、react等的客户端渲染，不过每一个都不是银弹，都有其对应的缺陷，所以为了提高前端渲染效率以及规范前后端分离范式，多种技术组合使用将是未来的发展趋势，那么认识基本的前端渲染有哪些、都做哪些工作、它们之间的区别、缺陷和优势将是我们能够熟练使用它们的基础，本文章将带读者一览前端渲染模式。

### 前端渲染模式一览

- 客户端渲染（CSR - Client-Side Rendering）
- 服务端渲染（SSR - Server-Side Rendering）
- 静态站点生成（SSG -  Static Site Generation）
- 增量静态生成（ISG - Incremental Static Generation）
- 同构渲染（Universal Rendering / Isomorphic Rendering）
- 边缘渲染（Edge Rendering）

### 客户端渲染

客户端渲染是我们现在接触最多的渲染方式，其主要的框架有：

- vue
- react
- angular

它的核心很简单，就是将站点的所有页面打包成一个统一的html、css、js文件一次性发送给客户端代理（浏览器），当用户需要访问哪些页面触发该页面的url时，框架打包的js文件中会有拦截浏览器向后端发送url请求的逻辑，然后通过该文件的某些逻辑进行页面的渲染，这个过程减少了请求页面时的网络消耗，所以在页面切换时可以非常迅速。

下面是其工作流：

![](.\image\Snipaste_2025-01-27_09-23-45.jpg)

看上去一切都很美好，但是其存在两个问题：

- 首次请求的资源太大了
- 每个页面的数据依然要请求服务器

#### 首次请求的资源太大了

我们从图中可以看到在第2、3步浏览器就获取了站点的所有渲染文件，一般来说，一个小型的项目的资源大小：

- html：50KB左右
- js：1MB左右
- CSS：1MB左右

加起来就有2MB左右大小了，有的读者可能会认为，不就**2MB**吗，现在千兆网络几毫秒不就加载完了？但是千兆网络是针对客户端来说的，客户端拥有千兆的下载速率，但是服务器的传输资源就非常昂贵了，**10Mbps**的服务器就需要**400块一个月**，换算成MB也就是每秒能传**1.25MB**，也就是说在400块一个月的服务器上，我要渲染一个小型项目仍然需要**1s**以上的时间，更不用说我们弄一个简单的博客网站，可能买的也就是**2、3Mbps**的网络，这个传输时间还要再翻**5倍**！作为一个普通的用户这个时间是难以忍受的。

虽然我们可以在首屏渲染完成前放一点动画增加用户等待资源加载时的趣味性，但是这只是一种曲线救国的方式，并不能从根本上改变首屏加载慢的事实。

还有的策略就是利用分包，将会造成dom渲染阻塞的js进行拆分，将首屏需要的资源先进行加载，后续资源可以通过异步加载，这样可以满足减少首屏渲染时间以及减少其他页面渲染的时间，但是这种又会花费大量的开发成本，需要进行成本权衡。

#### 每个页面的数据依然要请求服务器

实际上上面的CSR工作流图是不完整的，下图才是完整的：

![](.\image\Snipaste_2025-01-27_09-49-35.jpg)

也就是说我们前面所说的减少加载其他页面的网络请求的时间消耗不全对，实际上在网络畅通的情况下，页面渲染资源的请求并不会比页面数据的请求多出多少时间，但是优化确实还是有的。但是这样一来相对于SSR的优势就不明显了，并且还有首屏渲染问题、增加SEO复杂性，所以CSR对前端的优化来讲并不能说是进步，它更像是一种框架发展时带来的副作用，当然，它还是有一个很明显的**优点**：**前后端分离任务清晰**。

### 服务端渲染

服务端渲染简单来说就是只返回对应页面的html、css、js资源，只返回单页那就没有首屏渲染问题了，并且每个页面都可以单独构建SEO优化，所以SEO简单，其主要的框架有：

- next.js
- nuxt.js
- angular ssr

下面是服务端渲染的工作流：

![](.\image\Snipaste_2025-01-27_10-08-31.jpg)

SSR的工作流是不是看起来简单多了？但是简单的代价也是很沉重的，下面是SSR渲染的两个主要问题：

- 服务器负载过大
- 前后端逻辑杂糅

#### 服务器负载过大

我们可以观察SSR渲染工作流的第三个阶段，在CSR渲染中，服务器只承担数据的获取操作，但是在SSR渲染中服务器不只是获取数据，还要将数据生成对应的html、css、js文件，所以服务器的工作量增加了，如果是流量不那么大的场景还好，一旦并发量过多，很容易造成请求阻塞，导致页面渲染不出来，但是这种情况CSR也讨不到好处，毕竟数据还是需要通过服务器获取的，除非说静态页面比较多或者做了一些骨架屏，让用户的等待不那么枯燥。

#### 前后端逻辑杂糅

这是SSR最主要的问题，也是为什么CSR能打败SSR，成为后起之秀，归根结底还是应用的开发流被规范了，前面说的问题都是有解决方法的，负载过大那就使用负载均衡、缓存策略，但是开发流的复杂度问题是无法解决的。为了打造更大型的应用，前后端分离是必然的趋势，其主要考虑的点有：

- 简化开发和调试：无法通过热更新获取前端页面的最新状态，开发时可能需要一直清除缓存或者修改缓存策略。
- 简化拓展：前端项目和后端项目是分开的，这样前端的拓展就不需要过度依赖后端，而后端也只需要处理数据逻辑不需要考虑展示问题。

这些都是从程序员的开发体验出发的，有时候如果双方的缺陷都不是那么明显，那么优点就很耀眼了。

### 静态站点生成

静态站点生成就是十分古早原始的网站渲染方式了，简单来讲就是不需要进行ajax请求了，这极大的减少后端的压力，当然并不是说静态站点的内容就是完全无交互的，静态站点还是可以使用js的。

静态站点的工作流如下图：

![](.\image\Snipaste_2025-01-27_10-35-01.jpg)

如上图所示，服务器完全不需要处理任何页面生成的逻辑，浏览器也不需要对服务器进行任何ajax请求，就是那么简单愉快~

那么我们很快可以意识到一个问题，那就是静态站点并不会对不同用户展示不同页面，所以静态站点的使用场景很少。但是它的性能实在是太优秀了，所以很多框架都集成的静态站点生成的功能，它常和其他渲染方式（CSR、SSR）一同工作，简单来讲就是先发送HTML让页面先展示出来，后续再发送JavaScript来为dom绑定事件的操作，使页面活起来，这个过程有一个名称注水（hydration）——将事件注入dom。这个词听起来很陌生，通常会在一些ssr框架里见到，但是实际上我们在csr渲染中也使用过类似的方式，比如：

- 首屏加载动画
- 骨架屏

区别就是，注水不会大幅度的改变（甚至是不改变）页面的结构，但是这个思想给我们提供了很好的一个前端优化方向。

### 增量静态生成

增量静态生成是介于静态站点生成（SSG）和服务端渲染（SSR）之间的一种渲染技术，这种渲染技术是为了解决SSR渲染中切换页面时等待时间过长并且使静态站点能拥有一定的更新能力。简单来说，服务端会在构建时生成站点中需要ISG的页面的缓存，客户端进行请求时服务端返回的就是这些页面的缓存，所以减少了服务端生成页面造成的客户端等待的时间。但是读者可能会有疑惑，如果页面更新了怎么办？在next.js中进行了一个简单的处理，定义了一个revalidate变量，这个变量用于定义页面缓存的有效时间，如果超过这个时间页面将被服务器重新生成，但是在重新生成的过程会返回给客户端一个旧页面，以防止客户端白屏时间过长。所以增量实际上指的就是**可更新内容的静态站点**。

增量静态生成的工作流如下图：

![](.\image\Snipaste_2025-01-29_09-11-40.jpg)

于是ISG就会有三个问题：

- 过期资源的第一次访问时只能拿到旧页面
- 缓存更新时可能会造成过重的服务器负担
- 不适合频繁更新的页面

#### 过期资源的第一次访问时只能拿到旧页面

这个问题在工作流图中很清晰，也就是第4步，客户端为了进一步获取最新资源只能通过再次请求，这并不只是ISG的缺陷，还是http协议的缺陷，因为服务端更新完后的结果并不能通过服务器主动的推送到客户端，这就是所谓的取舍，客户端获取到旧页面所造成的成本损失和客户端迅速获取到页面内容展示之间的取舍。

#### 缓存更新时可能会造成过重的服务器负担

在next.js中，页面的缓存一般都是基于某个页面组，比如/blog/1就属于/blog下的一个子路径，而我们需要缓存的肯定是/blog这个路径下的所有子路径，当然，如果不嫌麻烦或者需求需要，也可以每个子路径独自有一套缓存逻辑（缓存有效时间），但是一般情况下我们都会将组进行缓存，那么一旦缓存时间失效，服务器就需要对整个组进行更新，相比起单页面多次更新，单次多页面更新可能会对服务器造成更大的负担。

#### 不适合频繁更新的页面

从上面的案例分析中我们就可以知道，ISG并不适合数据频繁更新的页面，所以ISG一般的使用场景为：

- 新闻站点和博客
- 商品详情页
- 文档站点
- 门户网站

### 同构渲染

同构渲染是CSR和SSR的结合，旨在解决首屏渲染白屏时间过长的问题。主要的工作模式就是首屏交给服务器渲染，之后的页面切换交给客户端渲染。

同构渲染工作流如下图所示：

![](.\image\Snipaste_2025-01-29_09-58-07.jpg)

其实就相当于单独拿出SSR或CSR都可以满足站点的渲染，实际上就是两个独立的服务，只是CSR后续的请求通过路由拦截不会向服务器发送页面渲染请求，而是通过内部js进行渲染，所以可以说同构渲染满足了SSR的优点（SEO、首屏），又有CSR的优点（页面切换快）。

从工作流图可以看出，要实现同构渲染最关键的一步就是第4步，当前页面资源和整个站点资源的返回它们之间的逻辑顺序。详细来说，服务器先返回了当前页的html、css、js资源，然后在html资源的最底部可能引入了一个script标签，这个标签用于引入整个站点的页面渲染逻辑，也就是我们CSR渲染中的main.js，不过这个main.js有一点不一样，就是其需要通过我们前面提到的技术hydration进行无感CSR代理。

看起来同构渲染很美好，什么优点都有，但是有一个**最致命的问题**：**同构渲染需要开发两个前端服务器，这是双倍的开发成本**。

### 边缘渲染

边缘渲染是SSR的一种拓展，利用分布式服务器的方式减轻了SSR服务器的压力，并且利用CDN模式减少了数据传输延时。

边缘渲染工作流如下图所示：

![](.\image\Snipaste_2025-01-29_10-48-07.jpg)

其中边缘节点通过无服务技术实现了代码执行的能力，以满足动态页面的生成。

这样来看，边缘渲染确实解决了首屏问题、SSR服务器压力问题等，但这个方案实现难度、成本都很高，使用这种方式需要考虑好投入和收效，不适合一般的小型项目。并且也不利于前后端分离：除了SSR模式主导以外，你要让前端程序员来管理边缘服务器在现阶段市场环境下显然也是不太现实的。

### 总结

前端渲染模式的提出无非是为了解决某个单一的前端渲染模式所不能解决的一些痛点问题，但是在每个渲染模式的提出之时，伴随的也是新的痛点的出现，所以在**前端渲染模式中没有银弹**。在每个前端渲染模式介绍的小节下我都提了一部分痛点，我在这里进行一个总结，前端渲染的痛点主要有：

- 首屏加载过慢问题
- 页面切换过慢问题
- seo问题
- 前后端分离问题
- 服务器压力问题
- 部署成本问题
- 使用场景局限问题

每个前端渲染模式针对这些痛点的解决情况如下：

| 渲染模式/痛点       | 首屏加载过慢问题 | 页面切换过慢问题 | seo问题 | 前后端分离问题 | 服务器压力问题 | 部署成本问题 | 使用场景局限问题   |
| ------------------- | ---------------- | ---------------- | ------- | -------------- | -------------- | ------------ | ------------------ |
| 客户端渲染（CSR）   | ❌                | ✅                | ❌       | ✅              | ✅              | ✅            | 任何场景           |
| 服务端渲染（SSR）   | ✅                | ❌                | ✅       | ❌              | ❌              | ✅            | 任何场景           |
| 静态站点生成（SSG） | ✅                | ✅                | ✅       | ❌              | ✅              | ✅            | 页面不更新的场景   |
| 增量静态生成（ISG） | ✅                | ✅                | ✅       | ❌              | ❌              | ✅            | 页面更新较少的场景 |
| 同构渲染（UR）      | ✅                | ✅                | ✅       | ✅              | ✅              | ❌            | 任何场景           |
| 边缘渲染（ER）      | ✅                | ✅                | ✅       | ❌              | ✅              | ❌            | 任何场景           |

### 参考文献

[next.js](https://nextjs.org/docs)

